{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { createAnimatedWrapper, getResolvedMetrics } from \"../Utils\";\nimport { getTransitionType } from \"./TransitionTypes\";\nimport * as Constants from \"../TransitionConstants\";\nimport TransitionItem from \"../TransitionItem\";\nimport { TransitionContext, RouteDirection, TransitionSpecification } from \"../Types\";\n\nvar getTransitionElements = function getTransitionElements(transitionElements, transitionContext) {\n  return transitionElements.map(function (item, idx) {\n    var routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);\n    var element = React.Children.only(item.reactElement.props.children);\n    var key = \"ti-\" + idx.toString();\n    var transitionStyle = getComponentStyle(item, routeDirection === RouteDirection.from ? transitionContext.delayCountFrom + 1 : transitionContext.delayCountTo + 1, routeDirection === RouteDirection.from ? transitionContext.delayIndexFrom : transitionContext.delayIndexTo, transitionContext);\n    var style = [transitionStyle, styles.transitionElement];\n\n    var props = _objectSpread(_objectSpread({}, element.props), {}, {\n      __index: item.index\n    });\n\n    element = React.createElement(element.type, _objectSpread(_objectSpread({}, props), {}, {\n      key: key\n    }));\n    var comp = createAnimatedWrapper({\n      component: element,\n      nativeStyles: style\n    });\n\n    if (item.delay) {\n      if (routeDirection === RouteDirection.from) {\n        transitionContext.delayIndexFrom += transitionContext.delayFromFactor;\n      } else {\n        transitionContext.delayIndexTo += transitionContext.delayToFactor;\n      }\n    }\n\n    return comp;\n  });\n};\n\nvar getComponentStyle = function getComponentStyle(item, delayCount, delayIndex, transitionContext) {\n  var index = transitionContext.getIndex();\n  var routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);\n  var progress = transitionContext.getTransitionProgress();\n  var routes = transitionContext.getRoutes();\n  var transitionStyle = progress ? getCalculatedTransitionStyle(item, delayCount, delayIndex, index, routeDirection, progress, routes.length === 1) : {};\n  var resolvedMetrics = getResolvedMetrics(item, item.metrics);\n  return _objectSpread({\n    left: resolvedMetrics.x,\n    top: resolvedMetrics.y,\n    width: resolvedMetrics.width,\n    height: resolvedMetrics.height\n  }, transitionStyle);\n};\n\nexport var getCalculatedTransitionStyle = function getCalculatedTransitionStyle(item, delayCount, delayIndex, index, routeDirection, progress, singleRoute) {\n  var transitionFunction = getTransitionFunction(item, routeDirection);\n\n  if (transitionFunction) {\n    var start = Constants.TRANSITION_PROGRESS_START;\n    var end = Constants.TRANSITION_PROGRESS_END;\n    var distance = !singleRoute ? (1.0 - (Constants.TRANSITION_PROGRESS_START + (1.0 - Constants.TRANSITION_PROGRESS_END))) * 0.5 : 1.0 - (Constants.TRANSITION_PROGRESS_START + (1.0 - Constants.TRANSITION_PROGRESS_END));\n\n    if (item.delay) {\n      var delayStep = distance / delayCount;\n\n      if (routeDirection === RouteDirection.from) {\n        start += delayStep * delayIndex;\n      } else {\n        end -= delayStep * delayIndex;\n      }\n    } else if (!singleRoute) {\n      if (routeDirection === RouteDirection.to) {\n        start += distance;\n      } else {\n        end -= distance;\n      }\n    }\n\n    var interpolatedProgress = progress.interpolate({\n      inputRange: [index - 1, index, index + 1],\n      outputRange: [0, 1, 0]\n    });\n    var transitionSpecification = {\n      progress: interpolatedProgress,\n      name: item.name,\n      route: item.route,\n      metrics: item.metrics,\n      boundingbox: item.boundingBoxMetrics,\n      direction: routeDirection,\n      dimensions: Dimensions.get('window'),\n      start: start,\n      end: end\n    };\n    return transitionFunction(transitionSpecification);\n  }\n\n  return {};\n};\n\nvar getTransitionFunction = function getTransitionFunction(item, routeDirection) {\n  var getTransition = function getTransition(transition) {\n    if (transition instanceof Function) {\n      return transition;\n    }\n\n    return getTransitionType(transition);\n  };\n\n  if (routeDirection === RouteDirection.to && item.appear) {\n    return getTransition(item.appear);\n  }\n\n  if (routeDirection === RouteDirection.from && item.disappear) {\n    return getTransition(item.disappear);\n  }\n\n  if (item.appear) {\n    return getTransition(item.appear);\n  }\n\n  return null;\n};\n\nvar styles = StyleSheet.create({\n  transitionElement: {\n    position: 'absolute'\n  }\n});\nexport { getTransitionElements };","map":{"version":3,"sources":["/Users/sadu/Sites/WC/rubikssoft/ecomerce-mob-app/node_modules/react-navigation-fluid-transitions/Transitions/getTransitionElements.js"],"names":["React","createAnimatedWrapper","getResolvedMetrics","getTransitionType","Constants","TransitionItem","TransitionContext","RouteDirection","TransitionSpecification","getTransitionElements","transitionElements","transitionContext","map","item","idx","routeDirection","getDirectionForRoute","name","route","element","Children","only","reactElement","props","children","key","toString","transitionStyle","getComponentStyle","from","delayCountFrom","delayCountTo","delayIndexFrom","delayIndexTo","style","styles","transitionElement","__index","index","createElement","type","comp","component","nativeStyles","delay","delayFromFactor","delayToFactor","delayCount","delayIndex","getIndex","progress","getTransitionProgress","routes","getRoutes","getCalculatedTransitionStyle","length","resolvedMetrics","metrics","left","x","top","y","width","height","singleRoute","transitionFunction","getTransitionFunction","start","TRANSITION_PROGRESS_START","end","TRANSITION_PROGRESS_END","distance","delayStep","to","interpolatedProgress","interpolate","inputRange","outputRange","transitionSpecification","boundingbox","boundingBoxMetrics","direction","dimensions","Dimensions","get","getTransition","transition","Function","appear","disappear","StyleSheet","create","position"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Dimensions, StyleSheet } from 'react-native';\n\nimport { createAnimatedWrapper, getResolvedMetrics } from '../Utils';\nimport { getTransitionType } from './TransitionTypes';\nimport * as Constants from '../TransitionConstants';\nimport TransitionItem from '../TransitionItem';\n\nimport {\n  TransitionContext,\n  RouteDirection,\n  TransitionSpecification,\n} from '../Types';\n\n\nconst getTransitionElements = (transitionElements: Array<TransitionItem>,\n  transitionContext: TransitionContext) => transitionElements.map((item, idx) => {\n  const routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);\n  let element = React.Children.only(item.reactElement.props.children);\n  const key = `ti-${idx.toString()}`;\n\n  const transitionStyle = getComponentStyle(\n    item, routeDirection === RouteDirection.from\n      ? transitionContext.delayCountFrom + 1 : transitionContext.delayCountTo + 1,\n    routeDirection === RouteDirection.from\n      ? transitionContext.delayIndexFrom : transitionContext.delayIndexTo,\n    transitionContext,\n  );\n\n  const style = [transitionStyle, styles.transitionElement];\n  const props = { ...element.props, __index: item.index };\n  element = React.createElement(element.type, { ...props, key });\n  const comp = createAnimatedWrapper({ component: element, nativeStyles: style });\n\n  if (item.delay) {\n    if (routeDirection === RouteDirection.from) {\n      transitionContext.delayIndexFrom += transitionContext.delayFromFactor;\n    } else {\n      transitionContext.delayIndexTo += transitionContext.delayToFactor;\n    }\n  }\n  return comp;\n});\n\nconst getComponentStyle = (\n  item: TransitionItem, delayCount: number, delayIndex: number,\n  transitionContext: TransitionContext,\n) => {\n  const index = transitionContext.getIndex();\n  const routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);\n  const progress = transitionContext.getTransitionProgress();\n  const routes = transitionContext.getRoutes();\n\n  const transitionStyle = progress ? getCalculatedTransitionStyle(\n    item,\n    delayCount,\n    delayIndex,\n    index,\n    routeDirection,\n    progress,\n    routes.length === 1,\n  ) : {};\n\n  const resolvedMetrics = getResolvedMetrics(item, item.metrics);\n  return {\n    left: resolvedMetrics.x,\n    top: resolvedMetrics.y,\n    width: resolvedMetrics.width,\n    height: resolvedMetrics.height,\n    ...transitionStyle,\n  };\n};\n\nexport const getCalculatedTransitionStyle = (\n  item,\n  delayCount,\n  delayIndex,\n  index,\n  routeDirection,\n  progress,\n  singleRoute,\n) => {\n  const transitionFunction = getTransitionFunction(item, routeDirection);\n  if (transitionFunction) {\n    // Calculate start/end to handle delayed transitions\n    let start = Constants.TRANSITION_PROGRESS_START;\n    let end = Constants.TRANSITION_PROGRESS_END;\n\n    const distance = !singleRoute\n      ? (1.0 - (Constants.TRANSITION_PROGRESS_START\n      + (1.0 - Constants.TRANSITION_PROGRESS_END))) * 0.5\n      : (1.0 - (Constants.TRANSITION_PROGRESS_START\n      + (1.0 - Constants.TRANSITION_PROGRESS_END)));\n\n    if (item.delay) {\n      // Start/stop in delay window\n      const delayStep = distance / delayCount;\n      if (routeDirection === RouteDirection.from) {\n        start += (delayStep * delayIndex);\n      } else {\n        end -= (delayStep * delayIndex);\n      }\n    } else if (!singleRoute) {\n      // Start/stop first/last half of transition\n      if (routeDirection === RouteDirection.to) {\n        start += distance;\n      } else {\n        end -= distance;\n      }\n    }\n\n    // console.log(item.name, delayIndex, routeDirection, delayCount, distance, start, end);\n\n    // Create progress interpolation\n    const interpolatedProgress = progress.interpolate({\n      inputRange: [index - 1, index, index + 1],\n      outputRange: [0, 1, 0],\n    });\n\n    const transitionSpecification: TransitionSpecification = {\n      progress: interpolatedProgress,\n      name: item.name,\n      route: item.route,\n      metrics: item.metrics,\n      boundingbox: item.boundingBoxMetrics,\n      direction: routeDirection,\n      dimensions: Dimensions.get('window'),\n      start,\n      end,\n    };\n\n    return transitionFunction(transitionSpecification);\n  }\n\n  return {};\n};\n\nconst getTransitionFunction = (item: TransitionItem, routeDirection: RouteDirection) => {\n  const getTransition = (transition: string | Function) => {\n    if (transition instanceof Function) { return transition; }\n    return getTransitionType(transition);\n  };\n\n  if (routeDirection === RouteDirection.to && item.appear) {\n    return getTransition(item.appear);\n  } if (routeDirection === RouteDirection.from && item.disappear) {\n    return getTransition(item.disappear);\n  } if (item.appear) {\n    return getTransition(item.appear);\n  }\n  return null;\n};\n\nconst styles = StyleSheet.create({\n  transitionElement: {\n    position: 'absolute',\n  },\n});\n\nexport { getTransitionElements };\n"]},"metadata":{},"sourceType":"module"}