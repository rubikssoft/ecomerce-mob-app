{"ast":null,"code":"import { RouteDirection, TransitionSpecification } from \"../Types\";\nexport var getHorizontalTransition = function getHorizontalTransition(transitionInfo) {\n  if (!transitionInfo || transitionInfo.metrics === undefined) {\n    return {};\n  }\n\n  var start = transitionInfo.start,\n      end = transitionInfo.end,\n      dimensions = transitionInfo.dimensions;\n  var startPosition = 0;\n  var endPosition = 0;\n\n  if (transitionInfo.direction === RouteDirection.from) {\n    startPosition = 0;\n    endPosition = -(dimensions.width + 25);\n  } else if (transitionInfo.direction === RouteDirection.to) {\n    startPosition = dimensions.width + 25;\n    endPosition = 0;\n  }\n\n  var transitionProgress = transitionInfo.progress.interpolate({\n    inputRange: [0, start, end, 1],\n    outputRange: [startPosition, startPosition, endPosition, endPosition]\n  });\n  return {\n    transform: [{\n      translateX: transitionProgress\n    }]\n  };\n};","map":{"version":3,"sources":["/Users/sadu/Sites/WC/rubikssoft/ecomerce-mob-app/node_modules/react-navigation-fluid-transitions/Transitions/getHorizontalTransition.js"],"names":["RouteDirection","TransitionSpecification","getHorizontalTransition","transitionInfo","metrics","undefined","start","end","dimensions","startPosition","endPosition","direction","from","width","to","transitionProgress","progress","interpolate","inputRange","outputRange","transform","translateX"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,uBAAzB;AAEA,OAAO,IAAMC,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,cAAD,EAA6C;AAClF,MAAI,CAACA,cAAD,IAAmBA,cAAc,CAACC,OAAf,KAA2BC,SAAlD,EAA6D;AAAE,WAAO,EAAP;AAAY;;AADO,MAG1EC,KAH0E,GAG/CH,cAH+C,CAG1EG,KAH0E;AAAA,MAGnEC,GAHmE,GAG/CJ,cAH+C,CAGnEI,GAHmE;AAAA,MAG9DC,UAH8D,GAG/CL,cAH+C,CAG9DK,UAH8D;AAKlF,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,WAAW,GAAG,CAAlB;;AAEA,MAAIP,cAAc,CAACQ,SAAf,KAA6BX,cAAc,CAACY,IAAhD,EAAsD;AACpDH,IAAAA,aAAa,GAAG,CAAhB;AACAC,IAAAA,WAAW,GAAG,EAAEF,UAAU,CAACK,KAAX,GAAmB,EAArB,CAAd;AACD,GAHD,MAGO,IAAIV,cAAc,CAACQ,SAAf,KAA6BX,cAAc,CAACc,EAAhD,EAAoD;AACzDL,IAAAA,aAAa,GAAGD,UAAU,CAACK,KAAX,GAAmB,EAAnC;AACAH,IAAAA,WAAW,GAAG,CAAd;AACD;;AAED,MAAMK,kBAAkB,GAAGZ,cAAc,CAACa,QAAf,CAAwBC,WAAxB,CAAoC;AAC7DC,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAIZ,KAAJ,EAAWC,GAAX,EAAgB,CAAhB,CADiD;AAE7DY,IAAAA,WAAW,EAAE,CAACV,aAAD,EAAgBA,aAAhB,EAA+BC,WAA/B,EAA4CA,WAA5C;AAFgD,GAApC,CAA3B;AAKA,SAAO;AAAEU,IAAAA,SAAS,EAAE,CAAC;AAAEC,MAAAA,UAAU,EAAEN;AAAd,KAAD;AAAb,GAAP;AACD,CAtBM","sourcesContent":["import { RouteDirection, TransitionSpecification } from '../Types';\n\nexport const getHorizontalTransition = (transitionInfo: TransitionSpecification) => {\n  if (!transitionInfo || transitionInfo.metrics === undefined) { return {}; }\n\n  const { start, end, dimensions } = transitionInfo;\n\n  let startPosition = 0;\n  let endPosition = 0;\n\n  if (transitionInfo.direction === RouteDirection.from) {\n    startPosition = 0;\n    endPosition = -(dimensions.width + 25);\n  } else if (transitionInfo.direction === RouteDirection.to) {\n    startPosition = dimensions.width + 25;\n    endPosition = 0;\n  }\n\n  const transitionProgress = transitionInfo.progress.interpolate({\n    inputRange: [0, start, end, 1],\n    outputRange: [startPosition, startPosition, endPosition, endPosition],\n  });\n\n  return { transform: [{ translateX: transitionProgress }] };\n};\n"]},"metadata":{},"sourceType":"module"}