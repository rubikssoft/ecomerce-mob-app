{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/sadu/Sites/WC/rubikssoft/ecomerce-mob-app/node_modules/react-navigation-fluid-transitions/FluidTransitioner.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport { NavigationActions, SceneView } from 'react-navigation';\nimport { Transitioner } from 'react-navigation-stack';\nimport clamp from 'lodash.clamp';\nimport TransitionItemsView from \"./TransitionItemsView\";\nimport TransitionRouteView from \"./TransitionRouteView\";\n\nvar emptyFunction = function emptyFunction() {};\n\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar RESPOND_THRESHOLD = 20;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 150;\n\nvar FluidTransitioner = function (_React$Component) {\n  _inherits(FluidTransitioner, _React$Component);\n\n  var _super = _createSuper(FluidTransitioner);\n\n  function FluidTransitioner(_props) {\n    var _this;\n\n    _classCallCheck(this, FluidTransitioner);\n\n    _this = _super.call(this, _props);\n    _this._scenes = [];\n    _this._gestureStartValue = 0;\n    _this._isResponding = false;\n    _this._immediateIndex = null;\n    _this._panResponder = null;\n\n    _this._transitionItemsViewOnLayout = function () {\n      _this._layoutsReady = true;\n\n      _this._checkScenesAndLayouts();\n    };\n\n    _this._onSceneReady = function (key) {\n      if (!_this._scenesReadyResolveFunc) {\n        return;\n      }\n\n      var sceneRenderInfo = _this._scenes.find(function (sri) {\n        return sri.key === key;\n      });\n\n      if (sceneRenderInfo) sceneRenderInfo.isMounted = true;\n\n      _this._checkScenesAndLayouts();\n    };\n\n    _this._onTransitionEnd = function (props, prevProps) {\n      var onTransitionEnd = _this.props.onTransitionEnd;\n      if (onTransitionEnd) return onTransitionEnd(props, prevProps);\n      return null;\n    };\n\n    _this._onTransitionStart = function () {\n      var onTransitionStart = _this.props.onTransitionStart;\n      if (onTransitionStart) return onTransitionStart();\n\n      if (_this._scenesReadyPromise) {\n        return _this._scenesReadyPromise;\n      }\n\n      return null;\n    };\n\n    _this._configureTransition = function (props, prevProps) {\n      var sceneTransitionConfig = {};\n\n      if (props) {\n        var moveForward = true;\n\n        if (prevProps && prevProps.index > props.index) {\n          moveForward = false;\n        }\n\n        var _ref = moveForward ? props : prevProps,\n            scene = _ref.scene;\n\n        var options = scene.descriptor.options;\n\n        if (options && options.transitionConfig) {\n          sceneTransitionConfig = options.transitionConfig;\n        }\n      }\n\n      var transitionConfig = _this.props.transitionConfig;\n      return _objectSpread(_objectSpread(_objectSpread({\n        timing: Animated.timing,\n        duration: 650,\n        easing: Easing.inOut(Easing.poly(4))\n      }, transitionConfig), sceneTransitionConfig), {}, {\n        isInteraction: true,\n        useNativeDriver: true\n      });\n    };\n\n    _this.renderTransitionView = function (props, prevProps) {\n      _this._layoutsReady = false;\n      var position = props.position;\n      var scene = props.scene,\n          layout = props.layout;\n      var navigation = scene.descriptor.navigation;\n\n      _this._animatedSubscribeForNativeAnimation(props.position);\n\n      _this._updateSceneArray(props.scenes);\n\n      var toRoute = props.scene.route.key;\n      var fromRoute = prevProps ? prevProps.scene.route.key : null;\n      var index = props.scene.index;\n\n      if (!fromRoute) {\n        fromRoute = index > 0 ? props.scenes[index - 1].route.key : null;\n      }\n\n      if (prevProps && index < prevProps.index && fromRoute === prevProps.scene.route.key) {\n        index = prevProps.index;\n        var tmp = fromRoute;\n        fromRoute = toRoute;\n        toRoute = tmp;\n      }\n\n      var handlers = _this.getPanResponderHandlers(position, index, scene, layout, navigation, props);\n\n      var scenes = props.scenes.map(function (scene) {\n        return _this._renderScene(_objectSpread(_objectSpread({}, props), {}, {\n          scene: scene\n        }));\n      });\n      return React.createElement(TransitionItemsView, _extends({}, handlers, {\n        navigation: _this.props.navigation,\n        style: _this.props.style,\n        progress: props.position,\n        fromRoute: fromRoute,\n        toRoute: toRoute,\n        index: index,\n        onLayout: _this._transitionItemsViewOnLayout,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 223,\n          columnNumber: 7\n        }\n      }), scenes);\n    };\n\n    _this._getSceneTransitionConfiguration = function (routeName, navigation) {\n      var route = navigation.state;\n      var descriptor = _this.props.descriptors;\n      var props = {\n        navigation: navigation,\n        scene: {\n          route: route,\n          descriptor: descriptor\n        }\n      };\n      return _this._configureTransition(props);\n    };\n\n    _this._scenesReadyPromise = new Promise(function (resolve) {\n      return _this._scenesReadyResolveFunc = resolve;\n    });\n    return _this;\n  }\n\n  _createClass(FluidTransitioner, [{\n    key: \"_animatedSubscribeForNativeAnimation\",\n    value: function _animatedSubscribeForNativeAnimation(animatedValue) {\n      if (!animatedValue) return;\n      if (!this._configureTransition().useNativeDriver) return;\n\n      if (Object.keys(animatedValue._listeners).length === 0) {\n        animatedValue.addListener(emptyFunction);\n      }\n    }\n  }, {\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var navigation = this.props.navigation;\n      return {\n        route: navigation.state.routes[navigation.state.index].key,\n        onSceneReady: this._onSceneReady,\n        getTransitionConfig: this._getSceneTransitionConfiguration\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          navigation = _this$props.navigation,\n          descriptors = _this$props.descriptors;\n      return React.createElement(Transitioner, {\n        configureTransition: this._configureTransition,\n        render: this.renderTransitionView,\n        navigation: navigation,\n        descriptors: descriptors,\n        onTransitionStart: this._onTransitionStart,\n        onTransitionEnd: this._onTransitionEnd,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 73,\n          columnNumber: 7\n        }\n      });\n    }\n  }, {\n    key: \"_checkScenesAndLayouts\",\n    value: function _checkScenesAndLayouts() {\n      var _this2 = this;\n\n      if (this._layoutsReady && !this._scenes.find(function (sri) {\n        return !sri.isMounted;\n      })) {\n        if (this._scenesReadyResolveFunc) {\n          this._scenesReadyResolveFunc();\n\n          this._scenesReadyPromise = new Promise(function (resolve) {\n            return _this2._scenesReadyResolveFunc = resolve;\n          });\n        }\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return this.props !== nextProps;\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(position, resetToIndex, duration) {\n      Animated.timing(position, {\n        toValue: resetToIndex,\n        duration: duration,\n        easing: Easing.EaseInOut,\n        useNativeDriver: position.__isNative\n      }).start();\n    }\n  }, {\n    key: \"_goBack\",\n    value: function _goBack(navigation, position, scenes, backFromIndex, duration) {\n      var _this3 = this;\n\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this._immediateIndex = toValue;\n      Animated.timing(position, {\n        toValue: toValue,\n        duration: duration,\n        easing: Easing.EaseInOut,\n        useNativeDriver: position.__isNative\n      }).start(function () {\n        _this3._immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (!_this3._isResponding && backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n        }\n      });\n    }\n  }, {\n    key: \"getPanResponderHandlers\",\n    value: function getPanResponderHandlers(position, index, scene, layout, navigation, props) {\n      var _this4 = this;\n\n      var mode = this.props.mode;\n      var isVertical = mode !== 'card';\n      var options = scene.descriptor.options;\n      var gestureDirectionInverted = options.gestureDirection === 'inverted';\n      var gesturesEnabled = typeof options.gesturesEnabled === 'boolean' ? options.gesturesEnabled : Platform.OS === 'ios';\n\n      if (this._panResponder) {\n        var handle = this._panResponder.getInteractionHandle();\n\n        if (handle) {\n          InteractionManager.clearInteractionHandle(handle);\n        }\n      }\n\n      this._panResponder = !gesturesEnabled ? null : PanResponder.create({\n        onPanResponderTerminate: function onPanResponderTerminate() {\n          _this4._isResponding = false;\n\n          _this4._reset(position, index, 0);\n        },\n        onPanResponderGrant: function onPanResponderGrant() {\n          position.stopAnimation(function (value) {\n            _this4._isResponding = true;\n            _this4._gestureStartValue = value;\n          });\n        },\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(event, gesture) {\n          if (index !== scene.index) {\n            return false;\n          }\n\n          var immediateIndex = _this4._immediateIndex == null ? index : _this4._immediateIndex;\n          var currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n          var currentDragPosition = event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n          var axisLength = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n          var axisHasBeenMeasured = !!axisLength;\n          var screenEdgeDistance = gestureDirectionInverted ? axisLength - (currentDragPosition - currentDragDistance) : currentDragPosition - currentDragDistance;\n          var _options$gestureRespo = options.gestureResponseDistance,\n              userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n          var gestureResponseDistance = isVertical ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n          if (screenEdgeDistance > gestureResponseDistance) {\n            return false;\n          }\n\n          var hasDraggedEnough = Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n          var isOnFirstCard = immediateIndex === 0;\n          var shouldSetResponder = hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n          return shouldSetResponder;\n        },\n        onPanResponderMove: function onPanResponderMove(event, gesture) {\n          var startValue = _this4._gestureStartValue;\n          var axis = isVertical ? 'dy' : 'dx';\n          var axisDistance = isVertical ? layout.height.__getValue() * 0.75 : layout.width.__getValue();\n          var currentValue = (I18nManager.isRTL && axis === 'dx') !== gestureDirectionInverted ? startValue + gesture[axis] / axisDistance : startValue - gesture[axis] / axisDistance;\n          var value = clamp(index - 1, currentValue, index);\n          position.setValue(value);\n        },\n        onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {\n          return false;\n        },\n        onPanResponderRelease: function onPanResponderRelease(event, gesture) {\n          if (!_this4._isResponding) {\n            return;\n          }\n\n          _this4._isResponding = false;\n          var immediateIndex = _this4._immediateIndex == null ? index : _this4._immediateIndex;\n          var axisDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();\n          var movementDirection = gestureDirectionInverted ? -1 : 1;\n          var movedDistance = movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n          var gestureVelocity = movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n          var defaultVelocity = axisDistance / ANIMATION_DURATION;\n          var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n          var resetDuration = gestureDirectionInverted ? (axisDistance - movedDistance) / velocity : movedDistance / velocity;\n          var goBackDuration = gestureDirectionInverted ? movedDistance / velocity : (axisDistance - movedDistance) / velocity;\n          position.stopAnimation(function (value) {\n            if (gestureVelocity < -0.5) {\n              _this4._reset(position, immediateIndex, resetDuration);\n\n              return;\n            }\n\n            if (gestureVelocity > 0.5) {\n              _this4._goBack(navigation, position, props.scenes, immediateIndex, goBackDuration);\n\n              return;\n            }\n\n            if (value <= index - POSITION_THRESHOLD) {\n              _this4._goBack(navigation, position, props.scenes, immediateIndex, goBackDuration);\n            } else {\n              _this4._reset(position, immediateIndex, resetDuration);\n            }\n          });\n        }\n      });\n      var handlers = gesturesEnabled ? this._panResponder.panHandlers : {};\n      return handlers;\n    }\n  }, {\n    key: \"_renderScene\",\n    value: function _renderScene(transitionProps) {\n      var scene = transitionProps.scene,\n          position = transitionProps.position;\n      var index = scene.index;\n      var navigation = scene.descriptor.navigation;\n      var screenProps = this.props.screenProps;\n      return React.createElement(TransitionRouteView, {\n        style: [styles.scene, this.getOpacityStyle(transitionProps.position, index)],\n        key: transitionProps.scene.route.key,\n        route: scene.route.key,\n        isActive: scene.isActive,\n        position: position,\n        index: index,\n        sceneKey: scene.key,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 368,\n          columnNumber: 7\n        }\n      }, React.createElement(SceneView, {\n        navigation: navigation,\n        screenProps: screenProps,\n        component: scene.descriptor.getComponent(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 377,\n          columnNumber: 9\n        }\n      }));\n    }\n  }, {\n    key: \"getOpacityStyle\",\n    value: function getOpacityStyle(position, index) {\n      return {\n        opacity: position.interpolate({\n          inputRange: [index - 1, index - 0.25, index, index + 0.25, index + 1],\n          outputRange: [0, 1, 1, 1, 0]\n        })\n      };\n    }\n  }, {\n    key: \"_updateSceneArray\",\n    value: function _updateSceneArray(scenes) {\n      var _this5 = this;\n\n      scenes.forEach(function (scene) {\n        if (!_this5._scenes.find(function (sri) {\n          return sri.key === scene.key;\n        })) {\n          _this5._scenes = [].concat(_toConsumableArray(_this5._scenes), [{\n            key: scene.key,\n            isMounted: false\n          }]);\n        }\n      });\n      var toDelete = [];\n\n      this._scenes.forEach(function (sri) {\n        if (!scenes.find(function (scene) {\n          return scene.key === sri.key;\n        })) {\n          toDelete.push(sri);\n        }\n      });\n\n      toDelete.forEach(function (sri) {\n        var index = _this5._scenes.indexOf(sri);\n\n        _this5._scenes = [].concat(_toConsumableArray(_this5._scenes.slice(0, index)), _toConsumableArray(_this5._scenes.slice(index + 1)));\n      });\n    }\n  }]);\n\n  return FluidTransitioner;\n}(React.Component);\n\nFluidTransitioner.childContextTypes = {\n  route: PropTypes.string,\n  getTransitionConfig: PropTypes.func,\n  onSceneReady: PropTypes.func\n};\nvar styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  },\n  scene: {\n    position: 'absolute',\n    backgroundColor: 'transparent',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  },\n  sceneContent: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});\nexport default FluidTransitioner;","map":{"version":3,"sources":["/Users/sadu/Sites/WC/rubikssoft/ecomerce-mob-app/node_modules/react-navigation-fluid-transitions/FluidTransitioner.js"],"names":["React","PropTypes","NavigationActions","SceneView","Transitioner","clamp","TransitionItemsView","TransitionRouteView","emptyFunction","ANIMATION_DURATION","POSITION_THRESHOLD","RESPOND_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","FluidTransitioner","props","_scenes","_gestureStartValue","_isResponding","_immediateIndex","_panResponder","_transitionItemsViewOnLayout","_layoutsReady","_checkScenesAndLayouts","_onSceneReady","key","_scenesReadyResolveFunc","sceneRenderInfo","find","sri","isMounted","_onTransitionEnd","prevProps","onTransitionEnd","_onTransitionStart","onTransitionStart","_scenesReadyPromise","_configureTransition","sceneTransitionConfig","moveForward","index","scene","options","descriptor","transitionConfig","timing","Animated","duration","easing","Easing","inOut","poly","isInteraction","useNativeDriver","renderTransitionView","position","layout","navigation","_animatedSubscribeForNativeAnimation","_updateSceneArray","scenes","toRoute","route","fromRoute","tmp","handlers","getPanResponderHandlers","map","_renderScene","style","_getSceneTransitionConfiguration","routeName","state","descriptors","Promise","resolve","animatedValue","Object","keys","_listeners","length","addListener","routes","onSceneReady","getTransitionConfig","nextProps","resetToIndex","toValue","EaseInOut","__isNative","start","backFromIndex","Math","max","backFromScene","s","dispatch","back","immediate","mode","isVertical","gestureDirectionInverted","gestureDirection","gesturesEnabled","Platform","OS","handle","getInteractionHandle","InteractionManager","clearInteractionHandle","PanResponder","create","onPanResponderTerminate","_reset","onPanResponderGrant","stopAnimation","value","onMoveShouldSetPanResponder","event","gesture","immediateIndex","currentDragDistance","currentDragPosition","nativeEvent","axisLength","height","__getValue","width","axisHasBeenMeasured","screenEdgeDistance","gestureResponseDistance","userGestureResponseDistance","vertical","horizontal","hasDraggedEnough","abs","isOnFirstCard","shouldSetResponder","onPanResponderMove","startValue","axis","axisDistance","currentValue","I18nManager","isRTL","setValue","onPanResponderTerminationRequest","onPanResponderRelease","movementDirection","movedDistance","gestureVelocity","defaultVelocity","velocity","resetDuration","goBackDuration","_goBack","panHandlers","transitionProps","screenProps","styles","getOpacityStyle","isActive","getComponent","opacity","interpolate","inputRange","outputRange","forEach","toDelete","push","indexOf","slice","Component","childContextTypes","string","func","StyleSheet","container","top","left","right","bottom","backgroundColor","sceneContent"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { StyleSheet, Platform, Easing, I18nManager, Animated, PanResponder, InteractionManager } from 'react-native';\nimport { NavigationActions, SceneView } from 'react-navigation';\nimport { Transitioner } from 'react-navigation-stack';\nimport clamp from 'lodash.clamp';\n\nimport TransitionItemsView from './TransitionItemsView';\nimport TransitionRouteView from './TransitionRouteView';\n\nconst emptyFunction = () => {};\n\nconst ANIMATION_DURATION = 500;\nconst POSITION_THRESHOLD = 1 / 2;\nconst RESPOND_THRESHOLD = 20;\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 150;\n\ntype SceneRenderedInfo = {\n  key: string,\n  isMounted: boolean,\n};\n\nclass FluidTransitioner extends React.Component<*> {\n  constructor(props) {\n    super(props);\n\n    this._scenesReadyPromise = new Promise(resolve => this._scenesReadyResolveFunc = resolve);\n  }\n\n  _scenes: Array<SceneRenderedInfo> = [];\n\n  _scenesReadyResolveFunc: ?Function;\n\n  _scenesReadyPromise: ?Promise<void>;\n\n  _layoutsReady: boolean;\n\n  _gestureStartValue = 0;\n\n  _isResponding = false;\n\n  _immediateIndex = null;\n\n  _panResponder = null;\n\n  static childContextTypes = {\n    route: PropTypes.string,\n    getTransitionConfig: PropTypes.func,\n    onSceneReady: PropTypes.func,\n  }\n\n  _animatedSubscribeForNativeAnimation(animatedValue: Animated.Value) {\n    if (!animatedValue) return;\n    if (!this._configureTransition().useNativeDriver) return;\n    if (Object.keys(animatedValue._listeners).length === 0) {\n      animatedValue.addListener(emptyFunction);\n    }\n  }\n\n  getChildContext() {\n    const { navigation } = this.props;\n    return {\n      route: navigation.state.routes[navigation.state.index].key,\n      onSceneReady: this._onSceneReady,\n      getTransitionConfig: this._getSceneTransitionConfiguration,\n    };\n  }\n\n  render() {\n    const { navigation, descriptors } = this.props;\n    return (\n      <Transitioner\n        configureTransition={this._configureTransition}\n        render={this.renderTransitionView}\n        navigation={navigation}\n        descriptors={descriptors}\n        onTransitionStart={this._onTransitionStart}\n        onTransitionEnd={this._onTransitionEnd}\n      />\n    );\n  }\n\n  _transitionItemsViewOnLayout = () => {\n    this._layoutsReady = true;\n    this._checkScenesAndLayouts();\n  }\n\n  _onSceneReady = (key: string) => {\n    if (!this._scenesReadyResolveFunc) { return; }\n    // check if this is a scene we are waiting for\n    const sceneRenderInfo = this._scenes.find(sri => sri.key === key);\n    if (sceneRenderInfo) sceneRenderInfo.isMounted = true;\n    this._checkScenesAndLayouts();\n  }\n\n  _checkScenesAndLayouts() {\n    if (this._layoutsReady && !this._scenes.find(sri => !sri.isMounted)) {\n      if (this._scenesReadyResolveFunc) {\n        this._scenesReadyResolveFunc();\n\n        this._scenesReadyPromise = new Promise(\n          resolve => this._scenesReadyResolveFunc = resolve,\n        );\n      }\n    }\n  }\n\n  _onTransitionEnd = (props: any, prevProps: any): Promise<void> | void => {\n    const { onTransitionEnd } = this.props;\n    if (onTransitionEnd) return onTransitionEnd(props, prevProps);\n    return null;\n  }\n\n  _onTransitionStart = (): Promise<void> | void => {\n    const { onTransitionStart } = this.props;\n    if (onTransitionStart) return onTransitionStart();\n\n    if (this._scenesReadyPromise) {\n      return this._scenesReadyPromise;\n    }\n\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return this.props !== nextProps;\n  }\n\n  _configureTransition = (props, prevProps) => {\n    let sceneTransitionConfig = {};\n    if (props) {\n      let moveForward = true;\n      if (prevProps && prevProps.index > props.index) {\n        moveForward = false;\n      }\n      const { scene } = moveForward ? props : prevProps;\n      const { options } = scene.descriptor;\n      if (options && options.transitionConfig) {\n        sceneTransitionConfig = options.transitionConfig;\n      }\n    }\n\n    const { transitionConfig } = this.props;\n    return {\n      timing: Animated.timing,\n      duration: 650,\n      easing: Easing.inOut(Easing.poly(4)),\n      ...transitionConfig,\n      ...sceneTransitionConfig,\n      isInteraction: true,\n      useNativeDriver: true,\n    };\n  }\n\n  _reset(position, resetToIndex, duration) {\n    Animated.timing(position, {\n      toValue: resetToIndex,\n      duration,\n      easing: Easing.EaseInOut,\n      useNativeDriver: position.__isNative,\n    }).start();\n  }\n\n  _goBack(navigation, position, scenes, backFromIndex, duration) {\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    Animated.timing(position, {\n      toValue,\n      duration,\n      easing: Easing.EaseInOut,\n      useNativeDriver: position.__isNative,\n    }).start(() => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (!this._isResponding && backFromScene) {\n        navigation.dispatch(NavigationActions.back({\n          key: backFromScene.route.key,\n          immediate: true,\n        }));\n      }\n    });\n  }\n\n  renderTransitionView = (props, prevProps) => {\n    this._layoutsReady = false;\n\n    const { position } = props;\n    const { scene, layout } = props;\n    const { navigation } = scene.descriptor;\n\n    this._animatedSubscribeForNativeAnimation(props.position);\n    this._updateSceneArray(props.scenes);\n\n    let toRoute = props.scene.route.key;\n    let fromRoute = prevProps ? prevProps.scene.route.key : null;\n    let { index } = props.scene;\n\n    if (!fromRoute) {\n      fromRoute = index > 0 ? props.scenes[index - 1].route.key : null;\n    }\n\n    // If we are just returning to the previous page keep the same props\n    if (prevProps && index < prevProps.index && fromRoute === prevProps.scene.route.key) {\n      index = prevProps.index;\n      const tmp = fromRoute;\n      fromRoute = toRoute;\n      toRoute = tmp;\n    }\n\n    const handlers = this.getPanResponderHandlers(\n      position, index,\n      scene, layout, navigation, props,\n    );\n\n    const scenes = props.scenes.map(scene => this._renderScene({ ...props, scene }));\n\n    return (\n      <TransitionItemsView\n        {...handlers}\n        navigation={this.props.navigation}\n        style={this.props.style}\n        progress={props.position}\n        fromRoute={fromRoute}\n        toRoute={toRoute}\n        index={index}\n        onLayout={this._transitionItemsViewOnLayout}\n      >\n        {scenes}\n      </TransitionItemsView>\n    );\n  }\n\n  getPanResponderHandlers(position, index, scene, layout, navigation, props) {\n    const { mode } = this.props;\n    const isVertical = mode !== 'card';\n    const { options } = scene.descriptor;\n    const gestureDirectionInverted = options.gestureDirection === 'inverted';\n    const gesturesEnabled = typeof options.gesturesEnabled === 'boolean'\n      ? options.gesturesEnabled\n      : Platform.OS === 'ios';\n\n    // https://github.com/facebook/react-native/issues/8624\n    // https://github.com/react-navigation/react-navigation/issues/4144\n    if (this._panResponder) {\n      const handle = this._panResponder.getInteractionHandle();\n      if (handle) { InteractionManager.clearInteractionHandle(handle); }\n    }\n    this._panResponder = !gesturesEnabled\n\n      ? null\n      : PanResponder.create({\n        onPanResponderTerminate: () => {\n          this._isResponding = false;\n          this._reset(position, index, 0);\n        },\n        onPanResponderGrant: () => {\n          position.stopAnimation(value => {\n            this._isResponding = true;\n            this._gestureStartValue = value;\n          });\n        },\n        onMoveShouldSetPanResponder: (event, gesture) => {\n          if (index !== scene.index) {\n            return false;\n          }\n          const immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n          const currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n          const currentDragPosition = event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n          const axisLength = isVertical\n            ? layout.height.__getValue()\n            : layout.width.__getValue();\n          const axisHasBeenMeasured = !!axisLength;\n          // Measure the distance from the touch to the edge of the screen\n          const screenEdgeDistance = gestureDirectionInverted\n            ? axisLength - (currentDragPosition - currentDragDistance)\n            : currentDragPosition - currentDragDistance;\n          // Compare to the gesture distance relevant to card or modal\n          const {\n            gestureResponseDistance: userGestureResponseDistance = {},\n          } = options;\n          const gestureResponseDistance = isVertical\n            ? userGestureResponseDistance.vertical\n              || GESTURE_RESPONSE_DISTANCE_VERTICAL\n            : userGestureResponseDistance.horizontal\n              || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n          // GESTURE_RESPONSE_DISTANCE is about 25 or 30. Or 135 for modals\n          if (screenEdgeDistance > gestureResponseDistance) {\n            // Reject touches that started in the middle of the screen\n            return false;\n          }\n          const hasDraggedEnough = Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n          const isOnFirstCard = immediateIndex === 0;\n          const shouldSetResponder = hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n          return shouldSetResponder;\n        },\n        onPanResponderMove: (event, gesture) => {\n          // Handle the moving touches for our granted responder\n          const startValue = this._gestureStartValue;\n          const axis = isVertical ? 'dy' : 'dx';\n          const axisDistance = isVertical\n            ? layout.height.__getValue() * 0.75\n            : layout.width.__getValue();\n          const currentValue = (I18nManager.isRTL && axis === 'dx') !== gestureDirectionInverted\n            ? startValue + gesture[axis] / axisDistance\n            : startValue - gesture[axis] / axisDistance;\n          const value = clamp(index - 1, currentValue, index);\n          position.setValue(value);\n        },\n        onPanResponderTerminationRequest: () => false,\n        onPanResponderRelease: (event, gesture) => {\n          if (!this._isResponding) {\n            return;\n          }\n          this._isResponding = false;\n          const immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n          // Calculate animate duration according to gesture speed and moved distance\n          const axisDistance = isVertical\n            ? layout.height.__getValue()\n            : layout.width.__getValue();\n          const movementDirection = gestureDirectionInverted ? -1 : 1;\n          const movedDistance = movementDirection * gesture[isVertical ? 'dy' : 'dx'];\n          const gestureVelocity = movementDirection * gesture[isVertical ? 'vy' : 'vx'];\n          const defaultVelocity = axisDistance / ANIMATION_DURATION;\n          const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n          const resetDuration = gestureDirectionInverted\n            ? (axisDistance - movedDistance) / velocity\n            : movedDistance / velocity;\n          const goBackDuration = gestureDirectionInverted\n            ? movedDistance / velocity\n            : (axisDistance - movedDistance) / velocity;\n          // To asynchronously get the current animated value, we need to run stopAnimation:\n          position.stopAnimation(value => {\n            // If the speed of the gesture release is significant, use that as the indication\n            // of intent\n            if (gestureVelocity < -0.5) {\n              this._reset(position, immediateIndex, resetDuration);\n              return;\n            }\n            if (gestureVelocity > 0.5) {\n              this._goBack(navigation, position, props.scenes, immediateIndex, goBackDuration);\n              return;\n            }\n            // Then filter based on the distance the screen was moved. Over a third of\n            // the way swiped, and the back will happen.\n            if (value <= index - POSITION_THRESHOLD) {\n              this._goBack(navigation, position, props.scenes, immediateIndex, goBackDuration);\n            } else {\n              this._reset(position, immediateIndex, resetDuration);\n            }\n          });\n        },\n      });\n    const handlers = gesturesEnabled ? this._panResponder.panHandlers : {};\n    return handlers;\n  }\n\n  _renderScene(transitionProps) {\n    const { scene, position } = transitionProps;\n    const { index } = scene;\n    const { navigation } = scene.descriptor;\n    const { screenProps } = this.props;\n    return (\n      <TransitionRouteView\n        style={[styles.scene, this.getOpacityStyle(transitionProps.position, index)]}\n        key={transitionProps.scene.route.key}\n        route={scene.route.key}\n        isActive={scene.isActive}\n        position={position}\n        index={index}\n        sceneKey={scene.key}\n      >\n        <SceneView\n          navigation={navigation}\n          screenProps={screenProps}\n          component={scene.descriptor.getComponent()}\n        />\n      </TransitionRouteView>\n    );\n  }\n\n  getOpacityStyle(position: Animated.Value, index: number) {\n    return { opacity: position.interpolate({\n      inputRange: [index - 1, index - 0.25, index, index + 0.25, index + 1],\n      outputRange: [0, 1, 1, 1, 0],\n    }) };\n  }\n\n  _updateSceneArray(scenes: Array<any>) {\n    scenes.forEach(scene => {\n      if (!this._scenes.find(sri => sri.key === scene.key)) {\n        this._scenes = [...this._scenes, { key: scene.key, isMounted: false }];\n      }\n    });\n\n    const toDelete = [];\n    this._scenes.forEach(sri => {\n      if (!scenes.find(scene => scene.key === sri.key)) { toDelete.push(sri); }\n    });\n\n    toDelete.forEach(sri => {\n      const index = this._scenes.indexOf(sri);\n      this._scenes = [...this._scenes.slice(0, index), ...this._scenes.slice(index + 1)];\n    });\n  }\n\n  _getSceneTransitionConfiguration = (routeName: string, navigation: any) => {\n    const route = navigation.state;\n    const descriptor = this.props.descriptors;\n    const props = { navigation, scene: { route, descriptor } };\n    return this._configureTransition(props);\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  scene: {\n    position: 'absolute',\n    backgroundColor: 'transparent',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  sceneContent: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n\nexport default FluidTransitioner;\n"]},"metadata":{},"sourceType":"module"}